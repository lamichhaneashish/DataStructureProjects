package axl173530;import rbk.Graph;import rbk.Graph.Edge;import rbk.Graph.Factory;import rbk.Graph.GraphAlgorithm;import rbk.Graph.Vertex;import java.io.File;import java.util.Iterator;import java.util.LinkedList;import java.util.Scanner;public class PERT extends GraphAlgorithm <PERT.PERTVertex> {    LinkedList <Vertex> finishList; //stores the topological ordering of the vertices.    int topNum; //stores the topological ordering number of the vertex    int time; //time used to calculate discovery as well as finish time.    boolean acyclic;    int CriticalVertices; //counter for number of critical vertices.    int critical_path_length;  //stores the length of the critical path.    // Constructor for PERT is private. Create PERT instances with static method pert().    private PERT(Graph g) {        super(g, new PERTVertex(null));    }    /**     * Create a PERT instance on g, runs the algorithm.     * Returns PERT instance if successful. Returns null if G is not a DAG.     **/    public static PERT pert(Graph g, int[] duration) throws Exception {        PERT p = new PERT(g);        for (Vertex u : g) {            p.setDuration(u, duration[u.getIndex()]);        }        // Run PERT algorithm.  Returns false if g is not a DAG        if (p.pert()) {            return p;        } else {            return null;        }    }    public static void main(String[] args) throws Exception {        String graph = "10 13   1 2 1   2 4 1   2 5 1   3 5 1   3 6 1   4 7 1   5 7 1   5 8 1   6 8 1   6 9 1   7 10 1   8 10 1   9 10 1   0 3 2 3 2 1 3 2 4 1";        Scanner in;        // If there is a command line argument, use it as file from which        // input is read, otherwise use input from string.        in = args.length > 0 ? new Scanner(new File(args[0])) : new Scanner(graph);        Graph g = Graph.readDirectedGraph(in);        g.printGraph(false);        int[] duration = new int[g.size()];        for (int i = 0; i < g.size(); i++) {            duration[i] = in.nextInt();        }        PERT p = pert(g, duration);        if (p == null) {            System.out.println("Invalid graph: not a DAG");        } else {            System.out.println("Critical path length: " + p.criticalPath());            System.out.println("Number of critical vertices: " + p.numCritical());            System.out.println("u\tEC\tLC\tSlack\tCritical");            for (Vertex u : g) {                System.out.println(u + "\t" + p.ec(u) + "\t" + p.lc(u) + " \t  " + p.slack(u) + "\t\t " + p.critical(u));            }        }    }    // getters and setters for setting the vertex properties.    public Color getColor(Vertex u) {        return get(u).color;    }    public void setColor(Vertex u, Color color) {        get(u).color = color;    }    public Vertex getParent(Vertex u) {        return get(u).parent;    }    public void setParent(Vertex u, Vertex parent) {        get(u).parent = parent;    }    public long getFinishTime(Vertex u) {        return get(u).fin;    }    public void setFinishTime(Vertex u, int finishTime) {        get(u).fin = finishTime;    }    public long getDisTime(Vertex u) {        return get(u).dis;    }    public void setDisTime(Vertex u, int disTime) {        get(u).dis = disTime;    }    public int getDuration(Vertex u) {        return get(u).duration;    }    public void setDuration(Vertex u, int d) {        get(u).duration = d;    }    public void setTopNum(Vertex u, int topNum) {        get(u).top = topNum;    }    /**     * Set the critical path length to zero.     * If the graph is directed then proceed to perform the pert algorithm.     * Call depth first search on graph g. Initialize the earliest completion for every vertex to be the duration of the vertex (task) itself.     * For all the vertices in the topological order if the earliest completion time of the next task is smaller than est of current task + duration of next task     * then update the est of the next task.     * Update the critical path length accordingly.     * To calculate the latest completion time, initialize the latest completion time to be critical path length of the tasks.     * Reverse the topological ordering and check if the latest completion time of current task is greater than lct of the previous task - duration of previous task.     * If true, update lc accordingly.     *     * @return : True on Success, False on Failure.     * @throws Exception     */    public boolean pert() throws Exception {        critical_path_length = 0;        if (g.isDirected()) {            dfs(g);            for (Vertex u : g) {                get(u).ec = getDuration(u); // u.ec = du.            }            for (Vertex u : topologicalOrder()) { // LI : u.ec = ec(u) , propagate it to successor of u.                for (Edge e : g.incident(u)) {                    Vertex v = e.otherEnd(u);                    if (ec(v) < ec(u) + getDuration(v)) {                        get(v).ec = ec(u) + getDuration(v); // v.ec = u.ec + dv.                    }                }                if (critical_path_length < get(u).ec) {                    critical_path_length = get(u).ec;                }            }            for (Vertex u : g) {                get(u).lc = critical_path_length; // u.lc = CPL            }            Iterator <Vertex> reverseTopologicalOrder = topologicalOrder().descendingIterator();            while (reverseTopologicalOrder.hasNext()) {                Vertex u = reverseTopologicalOrder.next();                for (Edge e : g.incident(u)) {                    Vertex v = e.otherEnd(u);                    if (lc(u) > lc(v) - getDuration(v)) {                        get(u).lc = lc(v) - getDuration(v); // u.lc = v.lc - dv.                    }                }            }            return true;        }        return false;    }    /**     * Find the topological ordering using DFS algorithm.     * If the graph is acyclic then return the linkedlist containing the list of vertices in the topological ordering else     * throws exception.     *     * @return : LinkedList with topologically ordered vertices.     * @throws Exception     */    LinkedList <Vertex> topologicalOrder() throws Exception {        if (!g.isDirected()) {            throw new Exception("Graph is not directed !!");        }        acyclic = true;        topNum = g.size();        dfs(g);        if (acyclic) {            return finishList;        } else {            throw new Exception("Graph is not acyclic !!!");        }    }    /**     * Initializing the color to be white and parent to be null.     *     * @param g : Graph.     */    public void initialize(Graph g) {        for (Vertex u : g) {            setColor(u, Color.WHITE);            setParent(u, null);        }    }    /**     * Initialize the vertices of the graph to be of color white and their parents to null using helper method initialize.     * For every vertex in graph if the color is white then call helper function dfsVisit for visiting the vertex.     *     * @param g : Graph.     */    void dfs(Graph g) {        time = 0;        finishList = new LinkedList <>();        initialize(g);        // loop        for (Vertex u : g) {            if (get(u).color.equals(Color.WHITE)) {                dfsVisit(u);            }        }    }    /**     * LI : node's color is white.     * Set the color of the node to be grey to indicate that the node has been discovered. Similarly, increase the discovery time.     * For every vertex coming out of the vertex u, if their color is white then set their parent to be u and call visit them.     * If they are already discovered then the graph is acyclic.     * Set the finish time accordingly and change the color to black to indicate that the node has been visited.     * Similarly, set the topological number of the vertex and update the number for the next vertex.     * Add the vertex to the finishList linked list.     *     * @param u : vertex to be visited.     */    void dfsVisit(Vertex u) {        setColor(u, Color.GREY);        setDisTime(u, ++time);        for (Edge e : g.incident(u)) {            Vertex v = e.otherEnd(u);            if (getColor(v).equals(Color.WHITE)) {                setParent(v, u); // v.parent = u                dfsVisit(v);            } else if (getColor(v).equals(Color.GREY)) {                acyclic = false;            }        }        setFinishTime(u, ++time);        setColor(u, Color.BLACK);        setTopNum(u, topNum);        topNum = topNum - 1;        finishList.addFirst(u);    }    // The following methods are called after calling pert().    // Earliest time at which task u can be completed    public int ec(Vertex u) {        return get(u).ec;    }    // Latest completion time of u    public int lc(Vertex u) {        return get(u).lc;    }    /**     * @param u : task which slack is to be computed.     * @return returns the slack of the task u.     */    public int slack(Vertex u) {        return lc(u) - ec(u);    }    // Length of a critical path (time taken to complete project)    public int criticalPath() {        return critical_path_length;    }    /**     * @param u : vertex     * @return true if the slack of the given vertex is zero, else return false.     */    public boolean critical(Vertex u) {        if (slack(u) == 0) {            return true;        }        return false;    }    /**     * If slack is zero then increase the number of critical vertices.     * @return : return the number of critical vertices.     */    public int numCritical() {        for (Vertex u : g) {            if (slack(u) == 0) {                CriticalVertices++;            }        }        return CriticalVertices;    }    /**     * Represents the color of the nodes.     * White : not visited.     * GREY : discovered.     * BLACK : visited.     */    public enum Color {        WHITE, GREY, BLACK;    }    /**     * Stores the properties of the PERTVertex such as     * color, parent, duration, earliest completion time, latest completion, discovery time,     * finish time as the topological ordering number of the vertex.     */    public static class PERTVertex implements Factory {        Color color; //color of the vertex .. initially white        Vertex parent; // parent of the vertex        int duration; //duration of the vertex        int ec; // earliest completion time.        int lc; // latest completion time.        int dis; // discovery time        int fin; // finish time.        int top; // topological ordering number.        public PERTVertex(Vertex u) {            color = Color.WHITE;            parent = null;        }        public PERTVertex make(Vertex u) {            return new PERTVertex(u);        }    }}